'''operations on types'''
#disable warnings on circular import, it should be handled correctly
# pylint: disable=R0401

import logging
import ast
import collections
import inspect
import itertools as it
import re
import types

import task_types
import task_types.serialization
import task_types.TaskTypes


L = logging.getLogger(__name__)

CallTuple = collections.namedtuple('CallTuple', 'name attr args kwargs')


def parse_val(node):
    '''
    Recursively use an AST generated by ast.parse and return simpler representation

    Args:
        node (ast node): node to be examined

    Returns:
        Depending on the type;
        ex:
        - the string value if the node is an ast.Str
        - the number, if the node is ast.Num

    The AST nodes all have different properties, make them simpler to understand
    This is used by the decorator extracting code, and the deserialization code
    '''
    #need to have many branches to deal with the parse tree
    #pylint: disable=R0912
    if isinstance(node, ast.Str):
        ret = node.s
    elif isinstance(node, ast.Num):
        ret = node.n
    elif isinstance(node, ast.Attribute):
        ret = node.value.id + '.' + node.attr
    elif isinstance(node, ast.Tuple):
        ret = [parse_val(v) for v in node.elts]
    elif isinstance(node, ast.List):
        ret = [parse_val(v) for v in node.elts]
    elif isinstance(node, ast.Call):
        name, attr, args, kwargs = None, None, None, None
        if hasattr(node.func, 'id'):
            name = node.func.id
        if hasattr(node.func, 'attr'):
            attr = node.func.attr
        if hasattr(node, 'args'):
            args = [parse_val(a) for a in node.args]
        if hasattr(node, 'keywords'):
            kwargs = dict((kw.arg, parse_val(kw.value)) for kw in node.keywords)
        ret = CallTuple(name, attr, args, kwargs)
    elif isinstance(node, ast.Dict):
        ret = dict((parse_val(k), parse_val(v)) for k, v
                    in zip(node.keys, node.values))
    elif isinstance(node, ast.Name):
        ret = node.id
    else:
        raise ValueError('malformed string: %s', node)
    return ret


def _string_to_type(string):
    '''take a string, and return the instantiated type'''
    _type = None
    #strip leading characters until the '.', in case it's a qualified name
    if re.match(r'^\w+\.', string):
        string = string.rpartition('.')[-1]

    for name in task_types.TaskTypes.ALLOWED_TYPES:
        if string.startswith(name):
            _type = task_types.serialization.object_from_string_call(string)
            break

    if _type is None:
        L.debug('expected one of %s', task_types.TaskTypes.ALLOWED_TYPES)
        raise TypeError('Missing type for string: "%s"' % string)
    return _type


def convert_to_types(_type):
    '''Takes a string/dict/list/CallTuple description of a type, and creates the type object

    Args:
        _type: string/dict of {key: strings}, list of strings, CallTuple: where
               the string(s) are instantiated as their type

    Returns:
        Instantiated type

    >>> import task_types.TaskOps as to
    >>> to.convert_to_types(['tt.LongType'])
    [LongType()]
    >>> to.convert_to_types('tt.URIType("image/png")')
    URIType(category='image/png')
    >>> to.convert_to_types({'left': 'tt.LongType'})
    {'left': LongType()}

    '''
    if isinstance(_type, task_types.TaskTypes.BaseType):
        return _type
    elif inspect.isclass(_type) and issubclass(_type, task_types.TaskTypes.BaseType):
        return _type()
    elif isinstance(_type, (types.StringType, types.UnicodeType)):
        return _string_to_type(_type)
    elif isinstance(_type, list):
        ret = map(convert_to_types, _type)
        return ret
    elif isinstance(_type, dict):
        ret = dict((k, convert_to_types(v))
                   for k, v in _type.iteritems())
        return ret
    elif isinstance(_type, CallTuple):
        if _type.name:
            if not _type.name in task_types.TaskTypes.ALLOWED_TYPES:
                raise ValueError('%s is not a type' % _type.name)
            ret = eval('task_types.TaskTypes.' + _type.name)(*_type.args, **_type.kwargs)
        else:
            if not _type.attr in task_types.TaskTypes.ALLOWED_TYPES:
                raise ValueError('%s is not a type' % _type.attr)
            ret = eval('task_types.TaskTypes.' + _type.attr)(*_type.args, **_type.kwargs)
        return ret

    raise ValueError('Could not create type from %s', _type)


def convert_from_types(obj):
    '''takes a BaseType, or iterable of BaseTypes, and creates a string

    Args:
        obj (BaseClass): object to be string-afied

    Returns:
        string

    >>> import task_types.TaskOps as to
    >>> import task_types.TaskTypes as tt
    >>> to.convert_from_types(tt.DoubleType())
    'DoubleType()'

    '''
    if isinstance(obj, task_types.TaskTypes.BaseType):
        return repr(obj)
    elif isinstance(obj, list):
        return [convert_from_types(o) for o in obj]

    raise TypeError('Could not create string from %s (%s)',
                    str(obj), type(obj))


def ensure_types(type_list):
    '''Make sure that all elements of the type_list are types that are recognized

    Args:
        type_list: list that needs to be checked

    Returns:
        the type_list, but with any bare type converted to an instantiated type

    Raises:
        ValueError if the passed type isn't a BaseType

    >>> import task_types.TaskOps as to
    >>> import task_types.TaskTypes as tt
    >>> to.ensure_types([tt.LongType, tt.LongType])
    [LongType(), LongType()]
    >>> to.ensure_types(str)
    *** ValueError: Only BaseType is supported, received: <type 'str'> which is <type 'type'>

    '''
    type_list = make_iterable(type_list)
    if type_list:
        type_list = _ensure_list_typename(type_list)
    return type_list


def make_iterable(objs):
    '''take some object(s), see if they a scalar, and turn them into a list

    Args:
        objs (iterable/scalar): potential list

    Returns:
        if objs is iterable, returns as iterable, unless a string/unicode
        else, creates a tuple containing the scalar

    >>> import task_types.TaskOps as to
    >>> to.make_iterable('asdf')
    ['asdf']
    >>> to.make_iterable(('asdf', 'qwer'))
    ('asdf', 'qwer')

    '''
    # prefer lists to tuples because it makes json serialization more consistent

    #note: be careful of strings/unicode
    #if a function returns a string, don't want to take its len()
    if(isinstance(objs, types.StringType) or
       (isinstance(objs, type) and issubclass(objs, types.StringType))):
        return [objs]
    elif(isinstance(objs, types.UnicodeType) or
         (isinstance(objs, type) and issubclass(objs, types.UnicodeType))):
        return [str(objs)]
    # check if iterable
    elif not hasattr(objs, '__contains__'):
        if objs is None:
            objs = []
        else:
            objs = [objs]

    return objs


def _ensure_list_typename(typelist):
    '''make sure a list of types are actually all types we support'''
    return [ensure_typename(t) for t in typelist]


def ensure_typename(_type):
    '''check to make sure that the parameter types exist in the types module

    Args:
        _type: type to check

    Returns: _type

    Raises:
        ValueError: if _type isn't BaseType

    Note:
        if the type is a bare class, it instantiates the type:
            ie: LongType -> LongType()

    >>> import task_types.TaskOps as to
    >>> import task_types.TaskTypes as tt
    >>> to.ensure_typename(tt.LongType)
    LongType()
    >>> to.ensure_typename(str)
    *** ValueError: Only BaseType is supported, received: <type 'str'> which is <type 'type'>
    '''
    if(inspect.isclass(_type) and issubclass(_type, task_types.TaskTypes.BaseType)):
        #instantiate the type
        return _type()
    elif isinstance(_type, task_types.TaskTypes.BaseType):
        return _type
    else:
        raise ValueError('Only BaseType is supported, received: %s which is %s'
                         % (str(_type), str(type(_type))))


def check_accepts(accepts, args=None, kwargs=None):
    ''' ensure that the arguments match the accepts definition raises an exception if it fails

    Args:
        accepts: list of types that are expected for the parameters in the
                    function
        args: list of values that will be compared to the accepts list, to
                see if they conform or can be coerced to the correct type
        kwargs: Not currently used, needed for DictOf, if it's implemented

    Returns: List of arguments

    Raises:
        ValueError if input arg counts differ

    >>> import task_types.TaskOps as to
    >>> import task_types.TaskTypes as tt
    >>> to.check_accepts(tt.LongType, 0)
    [0L]
    >>> to.check_accepts(tt.StringType, "A_String")
    [u'A_String']
    >>> to.check_accepts((tt.StringType, tt.LongType), "StrType")
    ValueError: Input arg counts differ: args ['StrType'] (1) (0) vs \
        accepts [StringType(), LongType()]

    '''
    if args is None:
        args = list()
    #currently we don't use DictOf, if we ever do, delete the following
    if kwargs is not None:
        raise ValueError('Cannot use kwargs, DictOf is not enabled')

    #still need to set this to a blank dict
    if kwargs is None:
        kwargs = dict()

    if isinstance(accepts, task_types.TaskTypes.ListOf):
        #expand out list to match the arguments,
        #and recursively call
        check_accepts([accepts.subtype] * len(args), args)

    else:
        accepts = _ensure_list_typename(make_iterable(accepts))
        #make sure we have all types as instances, not classes
        accepts = convert_to_types(accepts)
        args = make_iterable(args)
        if len(args) + len(kwargs) != len(accepts):
            raise ValueError('Input arg counts differ: args %s (%d) '
                             'kwargs %s (%d) vs accepts %s (%d)'
                             % (str(args), len(args),
                                str(kwargs.items()), len(kwargs),
                                str(accepts), len(accepts)))

        args = [arg for arg in it.imap(_type_conforms,
                                       args or kwargs.values(), accepts)]
    return args


def returns_iterable(returns, ret):
    ''' ensure that the definition of return types and the actual returned values are
    in list shape.

    Args:
        returns: (Potential List of) types that are returned by the function

        ret: Actual return values

    Returns (list, list): list of types and list of returned values.
        If the task returns a single value, the second list will contain just that one value.
        Note that that value may as well be a list of items.

    Raises:
        ValueError if return arg counts differ
    '''
    # prefer lists to tuples because it makes json serialization more consistent

    returns_list = _ensure_list_typename(make_iterable(returns))
    ret_list = make_iterable(ret)

    if len(returns_list) == 1 and isinstance(returns_list[0], task_types.TaskTypes.ListOf):
        ret_list = [ret_list]

    if len(ret_list) != len(returns_list):
        raise ValueError('Return value counts differ: returned %d values, expected %d'
                         % (len(ret_list), len(returns_list)))

    return returns_list, ret_list


def _type_conforms(value_obj, type_obj):
    ''' check if the type of a value object matches that defined
    by the type_obj.

    This will also do type coercion if the expected type is a PythonBaseType.
    This allows treating ints to as longs, in case people forget to do 10L
    instead of 10.

    Returns the value_obj if the type conforms (might be a different object
    if coercion took place).
    '''
    if not isinstance(type_obj, task_types.TaskTypes.BaseType):
        raise ValueError('type object: "%s" of type "%s" is not subclass of BaseType'
                         % (str(type_obj), repr(type(type_obj))))

    if not type_obj.type_conforms(value_obj):
        raise ValueError('value object: "%s" of type "%s" doesnt conform to type object "%s"'
                         % (str(value_obj), repr(type(value_obj)), str(type_obj)))

    # might need to coerce the type for base python types (int, long, etc..)
    # and for non-basic types
    value_obj = type_obj.build_value(value_obj)

    return value_obj


def order_args(parameters, args_unordered):
    '''if necessary (ie: when the args are a dict), change them into a list
    so that they match the parameter list

    Args:
        parameters: a list of parameters
        arguments: potential dict of arguments

    Returns:
        value of arguments, turned into a list in the right order if a dict, arguments otherwise

    >>> import task_types.TaskOps as to
    >>> args = ['arg0', 'arg1', 'arg2']
    >>> dict_args = {'arg0': 0, 'arg1': 1, 'arg2': 2}
    >>> to.order_args(args, dict_args)
    [0, 1, 2]
    '''
    if isinstance(args_unordered, dict):
        if set(parameters) != set(args_unordered.keys()):
            raise ValueError('set of dict keys for decorator '
                             'does not match positional parameters of function')
        ordered = [args_unordered[p] for p in parameters]
    else:
        ordered = args_unordered

    return ordered
